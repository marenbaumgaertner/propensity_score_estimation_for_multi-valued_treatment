---
title: "Multi-valued data "
author: "Maren Baumg√§rtner"
output: 
  html_notebook:
    toc: true
    toc_float: true
    code_folding: show
---

```{r, message=FALSE, echo=FALSE,warning=FALSE}
# Import libraries and dataset
library(knitr)
library(plyr)
library(dplyr)
library(reshape2)
library(randomForest)
library(ggplot2)
library(caTools)
library(mlogit)
library(nnet)
library(caret)
library(glmnet)
library(naivebayes)
library(rpart)
library(randomForest)
library(MASS)
library(FNN)
library(e1071)
library(igraph)
library(caret)
library(sparklyr)
library(RSSL)
library(sgd)
library(MASS)
library(hdm)
library(predtools)
library(xgboost)
library(adabag)
library(rpart)
library(grf)
library(ada)
library(fastAdaboost)
library(causalDML)
library(binda)
library(kknn)
library(calibrate)
library(bartMachine)
library(ranger)
```

```{r}
#source("ml_wrapper.R")
#source("eval_functions.R")

set.seed(42)
options(scipen= 999)
```

## Create multi-valued train data

```{r}
n=2000
n_treatments=8
p=8

# define X matric of covariates
X = matrix(runif(n*p,-pi,pi),ncol=p)
#X = matrix(sample(-0:2, n * p, replace = TRUE), nrow = n, ncol = p) # just integers as values
```

## Propensity score function for multi-valued treatments

```{r}
# Define a function to assign probabilities based on the sign of X[1]
e_step <- function(x, n_treatments) {
  probabilities <- matrix(1/n_treatments, 1, n_treatments)
  p_class_1 <- ifelse(x[1] < 0, 0.7, 0.15)
  p_class_3 <- ifelse(x[1] > 0, 0.7, 0.15)
  p_class_2 <- 1 - p_class_1 - p_class_3
  probabilities[1:3] <- c(p_class_1, p_class_2, p_class_3)
  
  # normalize probabilities
  probabilities = probabilities/sum(probabilities)
  W = sample(1:n_treatments, 1, replace = TRUE, prob = probabilities)
  return(W)
}

# each treatment has the same probability
e_balanced <- function(x, n_treatments){
  probabilities <- matrix(1/n_treatments, 1, n_treatments)
  W = sample(1:n_treatments, 1, replace = TRUE, prob = probabilities)
  #list(probabilities, W)
  return(W)
}

e_continuous <- function(x, n_treatments){
  probabilities <- matrix(1/n_treatments, 1, n_treatments)
  probabilities[2] = pnorm(sin(x[1]))
  probabilities[3] = pnorm(cos(x[2] +  cos(x[3])))
  
  # normalize probabilities
  probabilities = probabilities/sum(probabilities)
  W = sample(1:n_treatments, 1, replace = TRUE, prob = probabilities)
  #list(probabilities, W)
  return(W)
}
# Apply the diffenrent functions to each row of X to get probabilities for W
# Apply the different functions to each row of X to get probabilities for W
W_balanced <- apply(X, 1, function(x) e_balanced(x, n_treatments))
W_continuous <- apply(X, 1, function(x) e_continuous(x, n_treatments))
W_step <- apply(X, 1, function(x) e_step(x, n_treatments))

hist(W_balanced)
hist(W_continuous)
hist(W_step)

# create list of different treatments
W_list <- list("balaced"=W_balanced,"continuous"=W_continuous,"step"=W_step)

```

```{r}
# define W
W = W_list[1]

W.levels <- sort(unique(W))

if(n_treatments != length(W.levels)){
  warning("Number of treatments has changed")
}
# join treatment status and covariates
dataset <- data.frame(W=W,X)

split_indices <- sample.split(dataset$W, SplitRatio = 0.8)
training_data <- dataset[split_indices, ]
test_data <- dataset[!split_indices, ]

W_training <- as.matrix(data.frame(W = training_data$W))
X_training <- as.matrix(data.frame(X[split_indices, ]))
W_test <-     as.matrix(data.frame(W = test_data$W))
X_test <-     as.matrix(data.frame(X[!split_indices, ]))
```
